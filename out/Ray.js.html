<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Ray.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Ray.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { GeomLine } from "./Line.js";


/**
 * An infinite line in one direction from a point
 * Represented by the parametric form of the equation for a line,
 *   p + t*v
 * t is constrained to be only positive. 
 * @param {GeomPoint}  p  Origination point for the ray.
 * @param {GeomVector} v  Direction vector of the ray.
 */ 
export class GeomRay extends GeomLine {

   // ccw &amp; orient for points: same as lines  
   
   // ccw &amp; orient for rays:
   // Rays can cross one another so they are both clockwise and counter depending
   // but rays will sometimes have a specific orientation if not crossed
   
   
 /**
  * Get a point on the line
  * t = 0 is this.p.
  * Each increment of t by 1 is equal to adding the line vector magnitude 
  * to the line point. So if this.p = {0, 0, 0} and this.v = {10, 20, -10}, 
  * this.point(2) returns {20, 40, -20}. 
  * For rays, only positive t are permitted. Negative t will be changed to absolute
  *   value with a warning
  * @param {number} t  Increment, from line formula p + tâ€¢v
  * @return {GeomPoint} Point on the line
  */
  point(t) {
    if(t &lt; 0) {
      console.warn(`libgeometry|GeomRay.point parameters "t" is less than 0. Taking absolute value.`);
      t = Math.abs(t);
    }
    return GeomLine.prototype.point.call(this, t);
  }
   
  // -------------- MULTIPLE DISPATCH METHODS ------------- // 
  
  // parallel: just like lines
  // perpendicular: just like lines 
    
 /**
  * Does this ray intersect another ray or a line?
  * @override
  */
  intersects(r) {
    if(r.constructor !== GeomLine &amp;&amp; 
       r.constructor !== GeomRay) { return r._intersects(this); }
    return this._intersects(r);
  }
  
 /**
  * Private version of {@link intersects}.
  * @override
  * @private 
  */
  _intersects(r) {
    const t_values = this._intersectionTValues(r);
    if(!t_values) return false;
    
    // t values must be positive for rays
    // otherwise, the intersection happens before the ray starts
    if(t_values.t0 &lt; 0) return false;
    if(r instanceof GeomRay &amp;&amp; t_values.t1 &lt; 0) return false;
    return true;
  }
  
 /**
  * Does this ray intersect another ray or a line in 2D?
  * @override
  */
  intersects2D(r, { plane = GEOM.XY } = {}) {
    if(r.constructor !== GeomLine &amp;&amp; 
       r.constructor !== GeomRay) { return r._intersects(this, { plane }); }
    return this._intersects2D(r, { plane });
  }
  
 /**
  * Private version of {@link intersects2D}.
  * @override
  * @private 
  */
  _intersects2D(r) {
     const r0 = this.constructor.projectToPlane(this, plane);
     const r1 = r.constructor.projectToPlane(r, plane);
     return r0._intersects(r1);
  }
   
   
 /**
  * What is the intersection point, if any, between this ray and another ray or a line?
  * @override
  */
  intersection(r) {
    if(r.constructor !== GeomLine &amp;&amp; 
       r.constructor !== GeomRay) { return r._intersection(this); }
    return this._intersection(r);
  
  }
  
 /**
  * Private version of {@link intersection}.
  * @override
  */
  _intersection(r) {    
    const t_values = this._intersectionTValues(r);
    if(t_values === undefined) return false;
    if(t_values.t0 &lt; 0) return false;
    
    if(r instanceof GeomRay &amp;&amp; t_values.t1 &lt; 0) return false;
    
    const i0 = this.point(t_values.t0);
    const i1 = r.point(t_values.t1);
                 
    return i0.equivalent(i1) ? i0 : false;                  
  }  

 /**
  * What is the intersection point, if any, between this ray and another ray or a line
  *   projected on a 2D plane?
  * @override
  */
  intersection2D(r) {
    if(r.constructor !== GeomLine &amp;&amp; 
       r.constructor !== GeomRay) { return r._intersection2D(this); }
    return this._intersection2D(r);
  }
  
  
  _intersection2D(r, { plane = GEOM.XY, as_point = true } = {}) {
    const t_values = this._intersectionTValues(r, { in2D: true, plane: plane} );
    if(t_values === undefined) return false;
    if(t_values.t0 &lt; 0) return false;
    
    if(r instanceof GeomRay &amp;&amp; t_values.t1 &lt; 0) return false;
    
    const i0 = r0.point(t_values.t0);
    const i1 = r1.point(t_values.t1);
     
    const intersections_match = in2D ? 
           i0.equivalent2D(i1, plane) : i0.equivalent(i1)
             
    if(!intersections_match) return false;
    
    if(as_point) return intersection;

    // make a line, infinite in the non-plane direction
    const x = (plane === "YZ") ? 1 : intersection.x;
    const y = (plane === "XZ") ? 1 : intersection.y;
    const z = (plane === "XY") ? 1 : intersection.z;

    return GeomLine.fromPoints(intersection, new GeomPoint(x, y, z));
  }
  
 
  // -------------- DRAWING METHOD -------------- // 
       
 /**
  * Draw this segment extending across the entire canvas in one direction
  * @param {number} color
  * @param {number} alpha
  * @param {number} width
  */
  draw(color = COLORS.gray, alpha = 1, width = 1) {
    // draw from point to the canvas edge
    // to do so, locate the intersections of this line with the canvas
    //const canvas_edges = GeomLine.canvasEdges().filter(e => this.intersects2D(e, "XY") );
    const canvas_edges = GeomLine.canvasEdges().filter(e => this.intersects2D(e, "XY"));
    let intersections = canvas_edges.map(e => this.intersection2D(e, "XY") );

    // find the one intersection within the canvas
    intersections = intersections.filter(i => {
      const x_in = (i.x > 0 &amp;&amp; i.x &lt; canvas.dimensions.width) || 
                   almostEqual(i.x, 0) || 
                   almostEqual(i.x, canvas.dimensions.width);
  
      if(!x_in) return false;
  
      return (i.y > 0 &amp;&amp; i.y &lt; canvas.dimensions.height) || 
             almostEqual(i.y, 0) || 
             almostEqual(i.y, canvas.dimensions.height);
    });

    if(intersections.length === 0) {
      // could be simply vertical in the z direction. 
      ui.notifications.warn("No intersections with canvas edge found for line.");
      this.point(0).draw(color, alpha);
      return;
    }
    
    canvas.controls.debug
      .lineStyle(width, color, alpha)
      .moveTo(this.p.x, this.p.y)
      .lineTo(intersections[0].x, intersections[0].y);      
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="GeomLine.html">GeomLine</a></li><li><a href="GeomPixelLine.html">GeomPixelLine</a></li><li><a href="GeomPixelPoint.html">GeomPixelPoint</a></li><li><a href="GeomPixelVector.html">GeomPixelVector</a></li><li><a href="GeomPoint.html">GeomPoint</a></li><li><a href="GeomRay.html">GeomRay</a></li><li><a href="GeomVector.html">GeomVector</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clearDrawings">clearDrawings</a></li><li><a href="global.html#COLORS">COLORS</a></li><li><a href="global.html#GEOM">GEOM</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Wed Sep 29 2021 03:52:56 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
