<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Segment.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Segment.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { GeomRay } from "./Line.js";


/**
 * An line from one point to a second point
 * Represented by the parametric form of the equation for a line,
 *   p + t*v
 * t is constrained to be only between 0 and 1, where 0 gives p and 1 gives the endpoint.
 * v magnitude gives the end point.
 * @param {GeomPoint}  p  Origination point for the ray.
 * @param {GeomVector} v  Direction vector of the ray.
 */ 
export class GeomSegment extends GeomRay {

  constructor(p, v) {
    super(p, v);
    
    // for getters
    this._A = undefined;
    this._B = undefined;
  }
  
  // -------------------- GETTERS / SETTERS --------------- //
 /**
  * Starting point of the segment. Consistent with Foundry Ray class.
  * @type {GeomPoint}
  */
  get A() {
    if(this._A === undefined) { this._A = this.point(0); }
    return this._A;
  }
  
 /**
  * Ending point of the segment. Consistent with Foundry Ray class.
  * @type {GeomPoint}
  */ 
  get B() {
    if(this._B === undefined) { this._A = this.point(1); }
    return this._B;
  }
  
 /**
  * Change in distance along a dimension. Consistent with Foundry Ray class.
  * @type {number}
  */
  get dx() { return this.v.x; }
  get dy() { return this.v.y; }
  get dz() { return this.v.z; }
  
 /**
  * Distance of the segment. Consistent with Foundry Ray class.
  * @type {number}
  */
  get distance() { return this.v.magnitude; }
  get distanceXY() { return this.v.magnitudeXY; }
  get distanceXZ() { return this.v.magnitudeXZ; }
  get distanceYZ() { return this.v.magnitudeYZ; } 
  
 /**
  * A bounding rectangle that encompasses the segment along a plane.
  * @type {NormalizedRectangle}
  */
  get boundsXY() { return new NormalizedRectangle(this.A.x, this.A.y, this.dx, this.dy); }
  get boundsXZ() { return new NormalizedRectangle(this.A.x, this.A.z, this.dx, this.dz); }
  get boundsYZ() { return new NormalizedRectangle(this.A.y, this.A.z, this.dy, this.dz); }
  
  // -------------- METHODS --------------------- // 
  
 /**
  * Get a point on the line
  * t = 0 is this.p.
  * Each increment of t by 1 is equal to adding the line vector magnitude 
  * to the line point. So if this.p = {0, 0, 0} and this.v = {10, 20, -10}, 
  * this.point(2) returns {20, 40, -20}. 
  * For rays, only positive t are permitted. Negative t will be changed to absolute
  *   value with a warning
  * @override
  */
  point(t) {
    if(almostEqual(t, 0)) { t = 0; }
    if(t &lt; 0 || t > 1) {
      console.warn(`libgeometry|GeomSegment.point parameters "t" is less than 0 or greater than 1. Returning undefined.`);
      return undefined;
    }
    return GeomLine.prototype.point.call(this, t);
  }
  
 /**
  * Does this segment intersect another segment, ray or a line?
  * @override
  */
  intersects(sl) {
    if(l.constructor !== GeomLine &amp;&amp;
       l.constructor !== GeomRay &amp;&amp;
       l.constructor !== GeomSegment) { return l._intersects(this); }
    return this._intersects(l);   
  }
  
 /**
  * Private version of {@link intersects}.
  * Test segments using ccw
  * @override
  * @private 
  */
  _intersects(l) {
    const t_values = this._intersectionTValues(r);
    if(!t_values) { return false; }
    
    // t values must be between 0 and 1 for segments
    // otherwise, the intersection happens before the ray starts
    if(t_values.t0 &lt; 0 || t_values.t0 > 1) { return false; }
    if(l instanceof GeomSegment &amp;&amp; 
       (t_values.t1 &lt; 0 || t_values.t1 > 1)) { return false; }
  
    // could call GeomRay.prototype._intersect but it would repeat _intersectionTValues
    if(l instanceof GeomRay &amp;&amp; t_values.t1 &lt; 0) { return false; }
    
    return true;
  }
  
 /**
  * Does this ray intersect another ray or a line in 2D?
  * @override
  */
  intersects2D(l, { plane = GEOM.XY } = {}) {
    // if two segments, can use ccw to test for intersection
    if(l instanceof GeomSegment) {
      // this.A --> this.B --> s.A !== this.A --> B --> s.B &amp;&amp;
      // s.A --> s.B --> this.A !== s.A --> s.b --> this.B
      return this.ccw2D(l.A, { plane }) !== this.ccw2D(l.B, { plane }) &amp;&amp; 
             l.ccw2D(this.A, { plane }) !== l.ccw2D(this.B, { plane });    
    }
  
    if(l.constructor !== GeomLine &amp;&amp;
       l.constructor !== GeomRay &amp;&amp;
       l.constructor !== GeomSegment) { return l._intersects(this, { plane }); }
       
    return this._intersects2D(l, { plane });    
  }
  

  
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="GeomLine.html">GeomLine</a></li><li><a href="GeomPixelLine.html">GeomPixelLine</a></li><li><a href="GeomPixelPoint.html">GeomPixelPoint</a></li><li><a href="GeomPixelRay.html">GeomPixelRay</a></li><li><a href="GeomPixelSegment.html">GeomPixelSegment</a></li><li><a href="GeomPixelVector.html">GeomPixelVector</a></li><li><a href="GeomPoint.html">GeomPoint</a></li><li><a href="GeomRay.html">GeomRay</a></li><li><a href="GeomSegment.html">GeomSegment</a></li><li><a href="GeomVector.html">GeomVector</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clearDrawings">clearDrawings</a></li><li><a href="global.html#COLORS">COLORS</a></li><li><a href="global.html#GEOM">GEOM</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Wed Sep 29 2021 16:14:46 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
